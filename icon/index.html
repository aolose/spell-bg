<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>BG3 Spells</title>
    <style>html {
        background: #171829
    }</style>
    <link href="0.css" rel="stylesheet"/>
</head>
<body>
<div id="z"></div>
<div class="r">
    <div class="p">
        <div id="c">
        </div>
        <div class="f">
            <div class="v">
                <label>Label</label>
                <input id="v0"/>
            </div>
            <div class="v">
                <label>Value</label>
                <input id="v2"/>
            </div>
        </div>
    </div>
    <div class="g">
        <div id="a">
            <div id="v"></div>
        </div>
        <div id="b"></div>
        <div id="e">X</div>
    </div>
</div>
<script>
    const all = +0
    let l = 0
    const types = "%types%"
    const spells = {}
    let syncA = 0
    let icons = {}
    const m = 10
    const h = 160 + m
    const w = 400 + m
    const spellArr = []
    const filters = []
    function sz(){
        const y = Math.ceil(filters.length / x)
        sty.height = h * y + 20 + 'px'
    }
    function filter() {
        filters.length = 0
        const {t, k, l} = ft;
        spellArr.forEach((o, i) => {
            const f = (k, va) => {
                if (typeof va === 'string') {
                    va = va.replace(/unknown/gi, '');
                }
                if (k) {
                    if (k === '-') {
                        if (va) return;
                    } else if (k === '*') {
                        if (!va) return;
                    } else if (/^>\d+$/.test(k)) {
                        const g = +k.substr(1);
                        if (!isNaN(g)) {
                            let n = 0;
                            [].concat(va).forEach((v) => {
                                if (/^\d+$/.test(v)) {
                                    if (+v >= g) n = 1;
                                } else {
                                    const r = /DealDamage\((\d+)d(\d+),.*?\)/;
                                    const [, a, b] = r.exec(v) || [];
                                    if (b) {
                                        if (a * b >= g) n = 1;
                                    }
                                }
                            });
                            if (!n) return;
                        }
                    } else {
                        const v0 = (va + '').toLowerCase();
                        if (v0.indexOf((k + '').toLowerCase()) === -1) return;
                    }
                }
                return 1
            };
            if (t && t !== o.SpellType) return
            if (k && l) {
                for (const [kk, v] of Object.entries(o)) {
                    if (kk.toLowerCase() === k.toLowerCase()) {
                        if (!f(l, v)) return
                    }
                }
            }
            filters.push(i)
        })
        filters.sort((a, b) => {
            const la = spellArr[a].lv
            const lb = spellArr[b].lv
            if (la === lb) return a._nm > b._nm ? 1 : -1
            return la > lb ? 1 : -1
        })
        sz()
        syncA++
    }

    function mg(a) {
        if (!a) return
        if (!a._) {
            Object.keys(a).forEach(k => {
                if (!a[k]) delete a[k]
            })
            a._ = {}
        }
        const {Parent} = a
        if (Parent) {
            const pp = mg(spells[Parent]);
            if (pp) Object.keys(pp).forEach(k => {
                if (!a.hasOwnProperty(k)) {
                    a[k] = pp[k]
                    a._[k] = 1
                }
            })
        }
        a.nm = a.Name.replace(a.SpellType + "_", "")
            .replace(/_/g, " ")
            .replace(/([a-z0-9])([A-Z])/g, "$1 $2")
        a._nm = a.nm.toLowerCase()
        a.lv = +a.Level || 99
        const {SpellProperties, SpellSuccess} = a
        if (typeof SpellProperties === 'string') a.SpellProperties = [SpellProperties]
        if (typeof SpellSuccess === 'string') a.SpellSuccess = [SpellSuccess]
        a.ico = ico(a.Icon)
        return a
    }

    function ok() {
        const v = (++l * 100) / all
        z.style.width = v + '%'
        if (v === 100) z.style.opacity = '0'
    }

    const fx = a => (100 * a / (2048 - 64)).toFixed(5) + '%';

    function ico(k) {
        const o = icons[k];
        if (o) {
            const {U1, V1} = o;
            return `background-position:${fx(U1)} ${fx(V1)}`;
        }
        return "background-image:none";
    }

    function loadIcon(i) {
        icons = i
        Object.values(spells).forEach(
            o => o.ico = ico(o.Icon)
        );
        [].forEach.call(ctx.querySelectorAll('i'), a => {
            const n = a.parentElement.id
            const o = spells[n]
            a.style = o.ico
        })
    }

    function loadSpell(arr) {
        arr.forEach(a => {
            const name = a.Name
            spells[name] = a
            spellArr.push(a)
        })
        Object.values(spells).forEach(mg)
        filter()
    }
    const ft = {};
    const z = document.getElementById("z");
    const a = document.getElementById("a");
    const b = document.getElementById("b");
    const c = document.getElementById("c");
    const e = document.getElementById("e");
    const ctx = document.getElementById("v");
    let x = Math.max(1, Math.floor((a.offsetWidth - 20) / w))
    const sty = ctx.style
    function ps(o) {
        const base = ['Parent', 'UseCosts', 'Icon', 'SpellType', 'Level', 'Name']
        const v = Object.keys(o).filter(a => ['ico', 'nm', '_nm', 'lv'].indexOf(a) === -1);
        v.sort((a, b) => {
            const x = base.indexOf(a)
            const y = base.indexOf(b)
            if (x === y) return a > b ? 1 : -1
            return y - x
        })
        let c = "";
        v.forEach((k) => {
            if (k === '_') return
            const d = o[k];
            let s;
            if (Array.isArray(d)) {
                const ss = d.map((u) => `<li>${u}</li>`).join("");
                s = `<ul>${ss}</ul>`;
            } else s = `<span>${d}</span>`;
            const cls = o._ && o._[k] ? '_' : ''
            c += `<div>
<label class="${cls}">${k}</label>${s}
</div>`;
        });
        return c;
    }
    ctx.onclick = ev => {
        const c = ctx.children
        const t = ev.target
        const v = [].find.call(c, (a => a === c || a.contains(t)))
        const nm = v && v.id
        if (nm) {
            b.className = 's';
            e.className = 's';
            b.innerHTML = ps(spells[nm]);
        }
    }
    (e.onclick = function () {
        b.className = '';
        e.className = '';
        b.innerHTML = `<pre>
  Last build at %%
  filter ignore case.
· Label:
         The Property name of the spell.
· Value:
         The Value of the Property.
         '-' means empty.
         '*' means not empty.
         '>5' means equal or bigger than 5.
· e.g:
    Label: level  Value:-
</pre>`
    })();
    const el = (t) => {
        const e = document.createElement("div");
        e.innerHTML = t;
        return e.children[0];
    };
    let t = -1
    const tbs = [];
    const cg = (k, t) => {
        ft.t = t;
        tbs.forEach((t) => t.act(k));
    };
    [""].concat(types).forEach((t) => {
        const n = t || "ALL";
        const b = el(`<div>${n.toUpperCase()}</div>`);
        b.onclick = () => {
            cg(n, t);
        };
        b.act = (k) => {
            b.className = k === n ? "act" : "";
        };
        tbs.push(b);
        c.appendChild(b);
    });
    const xx = (id, key) => {
        const v = document.getElementById(id);
        v.oninput = v.onchange = v.onpaste = v.onblur = function () {
            ft[key] = v.value.replace(/^\s+|\s+$/, "");
            syncA++
        };
    };
    xx("v0", "k");
    xx("v2", "l");
    cg("ALL", "");

</script>
<script src="a.js" async></script>
%scripts%
</body>
</html>